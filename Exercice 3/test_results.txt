========================================================================
    Block Matrix Multiplication - Compilation and Testing Script
========================================================================

Date: Wed Jan 28 22:11:27 +01 2026
System: Linux DESKTOP-ECK83OG 6.6.87.2-microsoft-standard-WSL2 #1 SMP PREEMPT_DYNAMIC Thu Jun  5 18:30:46 UTC 2025 x86_64 x86_64 x86_64 GNU/Linux

========================================================================
                      SYSTEM CACHE INFORMATION
========================================================================
L1d cache:                            288 KiB (6 instances)
L1i cache:                            192 KiB (6 instances)
L2 cache:                             7.5 MiB (6 instances)
L3 cache:                             12 MiB (1 instance)

========================================================================
                          COMPILATION
========================================================================
Compiling mxm_bloc.c with optimization level -O2...
✓ Compilation successful!

========================================================================
                  TESTING DIFFERENT MATRIX SIZES
========================================================================

Matrix sizes to test: 256
Block sizes to test: 8, 16, 32, 64, 128, 256


========================================================================
                    MATRIX SIZE: 256x256
========================================================================

=================================================================
         BLOCK MATRIX MULTIPLICATION PERFORMANCE ANALYSIS        
=================================================================
Matrix size: 256 x 256
=================================================================

Allocating matrices...
Initializing matrices...

=================================================================
                    PERFORMANCE RESULTS                          
=================================================================

Block Size:    8 | Time:   0.0117 s | Bandwidth:    42.88 GB/s | GFLOPS:     2.88

Verifying correctness...
✓ Verification PASSED: Block multiplication is correct

Block Size:   16 | Time:   0.0083 s | Bandwidth:    60.25 GB/s | GFLOPS:     4.04
Block Size:   32 | Time:   0.0068 s | Bandwidth:    73.87 GB/s | GFLOPS:     4.96
Block Size:   64 | Time:   0.0081 s | Bandwidth:    61.54 GB/s | GFLOPS:     4.13
Block Size:  128 | Time:   0.0089 s | Bandwidth:    56.36 GB/s | GFLOPS:     3.78
Block Size:  256 | Time:   0.0123 s | Bandwidth:    40.66 GB/s | GFLOPS:     2.73

=================================================================
                      PERFORMANCE SUMMARY                        
=================================================================
Matrix Size:         256 x 256
Optimal Block Size:  32
Best Time:           0.0068 seconds
Best Bandwidth:      73.87 GB/s
Best Performance:    4.96 GFLOPS
=================================================================

=================================================================
                    PERFORMANCE ANALYSIS                         
=================================================================
Why Block Size 32 is Optimal:

1. Cache Utilization:
   - Block size 32 fits well in L1/L2 cache
   - Memory required per block: 24.00 KB
   - Reduces cache misses by reusing data in cache

2. Memory Access Pattern:
   - Block multiplication accesses memory in contiguous chunks
   - Better spatial locality improves cache hit rate
   - Reduces main memory accesses

3. TLB (Translation Lookaside Buffer) Efficiency:
   - Smaller working set reduces TLB misses
   - Improves virtual-to-physical address translation

4. Trade-offs:
   - Too small: High loop overhead, poor cache utilization
   - Too large: Exceeds cache capacity, causes thrashing
   - Optimal: Balances cache usage and loop overhead
=================================================================



========================================================================
                    MATRIX SIZE: 512x512
========================================================================

=================================================================
         BLOCK MATRIX MULTIPLICATION PERFORMANCE ANALYSIS        
=================================================================
Matrix size: 512 x 512
=================================================================

Allocating matrices...
Initializing matrices...

=================================================================
                    PERFORMANCE RESULTS                          
=================================================================

Block Size:    8 | Time:   0.0984 s | Bandwidth:    40.64 GB/s | GFLOPS:     2.73

Verifying correctness...
✓ Verification PASSED: Block multiplication is correct

Block Size:   16 | Time:   0.0713 s | Bandwidth:    56.14 GB/s | GFLOPS:     3.77
Block Size:   32 | Time:   0.0619 s | Bandwidth:    64.66 GB/s | GFLOPS:     4.34
Block Size:   64 | Time:   0.0618 s | Bandwidth:    64.70 GB/s | GFLOPS:     4.34
Block Size:  128 | Time:   0.1023 s | Bandwidth:    39.09 GB/s | GFLOPS:     2.62
Block Size:  256 | Time:   0.1045 s | Bandwidth:    38.27 GB/s | GFLOPS:     2.57

=================================================================
                      PERFORMANCE SUMMARY                        
=================================================================
Matrix Size:         512 x 512
Optimal Block Size:  64
Best Time:           0.0618 seconds
Best Bandwidth:      64.70 GB/s
Best Performance:    4.34 GFLOPS
=================================================================

=================================================================
                    PERFORMANCE ANALYSIS                         
=================================================================
Why Block Size 64 is Optimal:

1. Cache Utilization:
   - Block size 64 fits well in L1/L2 cache
   - Memory required per block: 96.00 KB
   - Reduces cache misses by reusing data in cache

2. Memory Access Pattern:
   - Block multiplication accesses memory in contiguous chunks
   - Better spatial locality improves cache hit rate
   - Reduces main memory accesses

3. TLB (Translation Lookaside Buffer) Efficiency:
   - Smaller working set reduces TLB misses
   - Improves virtual-to-physical address translation

4. Trade-offs:
   - Too small: High loop overhead, poor cache utilization
   - Too large: Exceeds cache capacity, causes thrashing
   - Optimal: Balances cache usage and loop overhead
=================================================================



========================================================================
                    MATRIX SIZE: 1024x1024
========================================================================

=================================================================
         BLOCK MATRIX MULTIPLICATION PERFORMANCE ANALYSIS        
=================================================================
Matrix size: 1024 x 1024
=================================================================

Allocating matrices...
Initializing matrices...

=================================================================
                    PERFORMANCE RESULTS                          
=================================================================

Block Size:    8 | Time:   0.7866 s | Bandwidth:    40.68 GB/s | GFLOPS:     2.73

Verifying correctness...
✓ Verification PASSED: Block multiplication is correct

Block Size:   16 | Time:   0.6093 s | Bandwidth:    52.52 GB/s | GFLOPS:     3.52
Block Size:   32 | Time:   0.5078 s | Bandwidth:    63.01 GB/s | GFLOPS:     4.23
Block Size:   64 | Time:   0.7740 s | Bandwidth:    41.34 GB/s | GFLOPS:     2.77
Block Size:  128 | Time:   0.8127 s | Bandwidth:    39.37 GB/s | GFLOPS:     2.64
Block Size:  256 | Time:   0.8515 s | Bandwidth:    37.58 GB/s | GFLOPS:     2.52

=================================================================
                      PERFORMANCE SUMMARY                        
=================================================================
Matrix Size:         1024 x 1024
Optimal Block Size:  32
Best Time:           0.5078 seconds
Best Bandwidth:      63.01 GB/s
Best Performance:    4.23 GFLOPS
=================================================================

=================================================================
                    PERFORMANCE ANALYSIS                         
=================================================================
Why Block Size 32 is Optimal:

1. Cache Utilization:
   - Block size 32 fits well in L1/L2 cache
   - Memory required per block: 24.00 KB
   - Reduces cache misses by reusing data in cache

2. Memory Access Pattern:
   - Block multiplication accesses memory in contiguous chunks
   - Better spatial locality improves cache hit rate
   - Reduces main memory accesses

3. TLB (Translation Lookaside Buffer) Efficiency:
   - Smaller working set reduces TLB misses
   - Improves virtual-to-physical address translation

4. Trade-offs:
   - Too small: High loop overhead, poor cache utilization
   - Too large: Exceeds cache capacity, causes thrashing
   - Optimal: Balances cache usage and loop overhead
=================================================================


========================================================================
                         TESTING COMPLETE
========================================================================

Summary:
- Tested matrix sizes: 256
- Block sizes tested: 8, 16, 32, 64, 128, 256
- Optimal block size identified for each matrix size

Results saved to: test_results.txt

Next steps:
1. Review the performance results in test_results.txt
2. Identify the optimal block size for each matrix size
3. Analyze why certain block sizes perform better
4. Consider cache hierarchy (L1, L2, L3) in your analysis
========================================================================

Test completed at: Wed Jan 28 22:11:34 +01 2026
